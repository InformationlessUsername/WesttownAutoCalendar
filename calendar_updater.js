const { addWeeks } = require("date-fns");
const { google } = require("googleapis");
const User = require("./models/user");
const { ToadScheduler, SimpleIntervalJob, AsyncTask } = require("toad-scheduler");
const scheduler = new ToadScheduler();
// get JSON from internet
const fetch = require("node-fetch");
const ical = require("node-ical");

const scopes = ["https://www.googleapis.com/auth/calendar"];
const client = new google.auth.GoogleAuth({
  keyFile: "./service_account_key.json",
  scopes,
});

const calendar = google.calendar({ version: "v3", auth: client });

// Async snooze function
const snooze = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

async function update_user(user) {
  // Get the user's ical feed
  fetch(user.ical_feed_url, { method: "GET" })
    .then((res) => res.text())
    .then((text) => {
      // Parse the raw iCal data
      const ical_events = ical.sync.parseICS(text);

      // Get a list of all the google calendar events for this user in the next 2 months
      gcal_events = calendar.events.list(
        {
          calendarId: user.email,
          timeMin: new Date().toISOString(),
          timeMax: addWeeks(new Date(), 8).toISOString(),
          singleEvents: true,
          orderBy: "startTime",
        },
        async (err, res) => {
          gcal_events = res.data.items;

          // For each Ical event
          // Written like this to allow for use of async calls *inside* the for loop
          for (const [key, ical_event] of Object.entries(ical_events)) {
            // Pause each iteration to avoid rate limiting
            await snooze(500);

            // If not an event (e.g. a timezone or calendar type entry), skip
            if (ical_event.type !== "VEVENT") continue;

            // Log basic info about the event
            console.log(`Event: ${ical_event.summary}\n\tID: ${ical_event.uid}`);

            // Create valid google calendar event ID for later use
            unique_descriptor = `AUTOGENERATED by Westtown AutoCal \n ID: ${ical_event.uid}`;

            // Skip this loop if the event already exists in google calendar
            if (gcal_events.filter((e) => e.description === unique_descriptor).length > 0) {
              console.log("\tAlready exists!");
              continue;
            }

            // console.log(
            //   "ðŸš€ ~ file: calendar_updater.js ~ line 111 ~ refactored_uid",
            //   refactored_uid
            // );

            calendar.events.insert({
              calendarId: user.email,
              resource: {
                start: {
                  dateTime: ical_event.start,
                  timeZone: ical_event.timeZone,
                },
                end: {
                  dateTime: ical_event.end,
                  timeZone: ical_event.timeZone,
                },
                summary: ical_event.summary,
                // Use description as unique identifier for google calendar event
                description: unique_descriptor,
                status: "confirmed",
              },
            });
          }
        }
      );
    });
}

// function update_all_users() {
//   // For all users in DB, update them using update_user function
//   User.find({}, (err, users) => {
//     for (var i = 0; i < users.length; i++) {
//       update_user(users[i]);
//     }
//   });
// }

// // Create task to check all BGs and schedule it for every 5 minutes (and immediately)
// const update_all_users_task = new AsyncTask("update all users' calendars", update_all_users, (err) => {
//   console.log(err);
// });

// scheduler.addSimpleIntervalJob(
//   new SimpleIntervalJob(
//     // Every 2 hours, check all users' feeds and update their calendars
//     { minutes: 2 * 60, runImmediately: true },
//     update_all_users_task
//   )
// );

update_user({
  email: "roo.turin@gmail.com",
  ical_feed_url:
    "https://westtown.myschoolapp.com/podium/feed/iCal.aspx?z=cOXDirz06uMqQcrHv6xbrJEZh%2bztBuNCX9t%2frXSVl9uF9N9e9STkQbfvqOeH5hif5C5Poq38hqp95ClTGrOdYv2SZKuaINsgs2cl8yqrZ6duI7AQz0l%2bW65hAdeshut4",
});

// Allow other files to access the update_user function
// So when a user sets up the service, it runs once for them
module.exports = { update_user };
