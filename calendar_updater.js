const { addWeeks } = require("date-fns");
const { google } = require("googleapis");
const User = require("./models/user");
const { ToadScheduler, SimpleIntervalJob, AsyncTask } = require("toad-scheduler");
const scheduler = new ToadScheduler();
// get JSON from internet
const fetch = require("node-fetch");
const ical = require("node-ical");
const cliProgress = require("cli-progress");

const scopes = ["https://www.googleapis.com/auth/calendar"];
const client = new google.auth.GoogleAuth({
  keyFile: "./service_account_key.json",
  scopes,
});

const calendar = google.calendar({ version: "v3", auth: client });

// Async snooze function
const snooze = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

async function update_user(user) {
  // Get the user's ical feed
  fetch(user.ical_feed_url, { method: "GET" })
    .then((res) => res.text())
    .then((text) => {
      // Parse the raw iCal data
      const ical_events = ical.sync.parseICS(text);

      // Create progress bar with denominator of number of ical events
      const progress_bar = new cliProgress.SingleBar({ linewrap: true }, cliProgress.Presets.shades_classic);
      // Subtracting 2 is a bodge to account for the first and last item not being actual events
      progress_bar.start(Object.keys(ical_events).length - 2, 0);
      console.log();

      // API call to the Google calendar API
      gcal_events = calendar.events.list(
        {
          // The user's primary calendar's ID = their email address
          calendarId: user.email,
          timeMin: new Date().toISOString(),
          // Goes more than 2 months just in case
          timeMax: addWeeks(new Date(), 12).toISOString(),
          // Ignore deleted events
          singleEvents: true,
          orderBy: "startTime",
        },
        // Written like this to allow for use of async calls *inside* the callback function
        async (err, res) => {
          gcal_events = res.data.items;

          // For each event in the user's ical feed, add it to the user's Google Calendar if it doesn't otherwise exist
          // Written like this to allow for use of async calls *inside* the for loop
          for (const [key, ical_event] of Object.entries(ical_events)) {
            // Pause each iteration to avoid rate limiting
            await snooze(500);

            // If not an event (e.g. a timezone or calendar type entry), skip
            if (ical_event.type !== "VEVENT") continue;

            // Log basic info about the event
            console.log(`\nEvent: ${ical_event.summary}\n\tID: ${ical_event.uid}`);

            // Create valid google calendar event ID for later use
            unique_descriptor = `AUTOGENERATED by Westtown AutoCal \n ID: ${ical_event.uid}`;

            // Skip this loop if the event already exists in google calendar
            if (gcal_events.filter((e) => e.description === unique_descriptor).length > 0) {
              console.log("\tAlready exists!");
              gcal_events = gcal_events.filter((obj) => {
                return obj.description !== unique_descriptor;
              });
            } else {
              // No trailing newline
              console.log("\tDoesn't exist; adding... ");

              calendar.events.insert({
                calendarId: user.email,
                resource: {
                  start: {
                    dateTime: ical_event.start,
                    timeZone: ical_event.timeZone,
                  },
                  end: {
                    dateTime: ical_event.end,
                    timeZone: ical_event.timeZone,
                  },
                  summary: ical_event.summary,
                  // Use description as unique identifier for google calendar event
                  description: unique_descriptor,
                  status: "confirmed",
                },
              });
            }
            // Update progress bar
            progress_bar.increment();
          }

          // Remove google calendar events made by this script that are no longer in the user's ical feed
          progress_bar.start(Object.keys(gcal_events).length, 0);
          for (const [key, gcal_event] of Object.entries(gcal_events)) {
            console.log(`\nEvent: ${gcal_event.summary}\n\tID: ${gcal_event.id}`);

            // Pause each iteration to avoid rate limiting
            await snooze(500);

            // Only delete events that are auto-generated by this script
            if (!gcal_event?.description?.includes("AUTOGENERATED by Westtown AutoCal")) {
              console.log("\tNot auto-generated; skipping...");
            }
            // Formatted with if and else for clearer code
            else {
              console.log("\taut-generated; removing...");
              calendar.events.delete({
                calendarId: user.email,
                eventId: gcal_event.id,
              });
            }
            // Update progress bar
            progress_bar.increment();
          }
        }
      );
    });
}

async function update_all_users() {
  // For all users in DB, update them using update_user function
  User.find({}, (err, users) => {
    for (var i = 0; i < users.length; i++) {
      user = users[i];
      update_user({ email: user.email, ical_feed_url: user.ical_feed_url });
    }
  });
}

// Create task to check all BGs and schedule it for every 5 minutes (and immediately)
const update_all_users_task = new AsyncTask("update all users' calendars", update_all_users, (err) => {
  console.log(err);
});

scheduler.addSimpleIntervalJob(
  new SimpleIntervalJob(
    // Every 2 hours, check all users' feeds and update their calendars
    { minutes: 2 * 60, runImmediately: true },
    update_all_users_task
  )
);

update_user({
  email: "roo.turin@gmail.com",
  ical_feed_url:
    "https://westtown.myschoolapp.com/podium/feed/iCal.aspx?z=cOXDirz06uMqQcrHv6xbrJEZh%2bztBuNCX9t%2frXSVl9uF9N9e9STkQbfvqOeH5hif5C5Poq38hqp95ClTGrOdYv2SZKuaINsgs2cl8yqrZ6duI7AQz0l%2bW65hAdeshut4",
});

// Allow other files to access the update_user function
// So when a user sets up the service, it runs once for them
module.exports = { update_user };
