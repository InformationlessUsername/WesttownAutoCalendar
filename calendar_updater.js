const { addWeeks } = require("date-fns");
const { google } = require("googleapis");
const User = require("./models/user");
const { ToadScheduler, SimpleIntervalJob, AsyncTask } = require("toad-scheduler");
const scheduler = new ToadScheduler();
// get JSON from internet
const fetch = require("node-fetch");
const ical = require("node-ical");
const cliProgress = require("cli-progress");
const fs = require("fs");
const { time } = require("console");

const scopes = ["https://www.googleapis.com/auth/calendar"];
const client = new google.auth.GoogleAuth({
  keyFile: "./service_account_key.json",
  scopes,
});

async function newline(count) {
  console.log("\n".repeat(count));
}

async function log_info(message, indent, extra = "") {
  // Get current date in format YYYY-MM-DD to write to that log file
  date = new Date().toISOString().slice(0, 10);
  log_file_path = `./logs/${date}.txt`;

  // console.log(message);

  indent = "\t".repeat(indent + 1);

  // Create new date object in format YYYY-MM-DD hh:mm:ss
  logged_time = new Date()
    .toISOString()
    .replace(/T/, " ")
    .replace(/\..+/, "")
    .replace("\n", "\n" + indent);

  if (extra != "") extra = JSON.stringify(extra).replace("\n", "\n" + indent);

  message = message.replace("\n", "\n" + indent);

  to_write = `${indent + logged_time}: \n${indent + message}\n${indent + extra}\n`;

  await fs.appendFileSync(log_file_path, to_write);
  return;
}

// Create calendar object to be used for API calls
const calendar = google.calendar({ version: "v3", auth: client });

// Resolves after ms milliseconds have passed
const snooze = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// Updates a specific user's calendar
// user object must have email and ical_feed_url properties
async function update_user(user) {
  log_info(`Updating ${user.email}'s calendar`, 0);

  // Get the user's ical feed
  fetch(user.ical_feed_url, { method: "GET" })
    // Convert to text to allow parsing
    .then((res) => res.text())
    .then((text) => {
      // Parse the raw ical data
      const ical_events = ical.sync.parseICS(text);

      /* ======================================== Progress Bar ======================================== */
      //Create progress bar with denominator of number of ical events
      const progress_bar = new cliProgress.SingleBar(
        { linewrap: true, barsize: 80 },
        cliProgress.Presets.shades_classic
      );
      // Subtracting 2 is a bodge to account for the first and last item not being actual events
      progress_bar.start(Object.keys(ical_events).length - 2, 0);
      newline(1);
      /* ============================================================================================== */

      /* ================================= Get Google Calendar Events ================================= */
      // API call to the Google calendar API
      gcal_events = calendar.events.list(
        {
          // The user's primary calendar's ID = their email address
          calendarId: user.email,
          timeMin: new Date().toISOString(),
          // Goes more than 2 months just in case
          timeMax: addWeeks(new Date(), 12).toISOString(),
          // Ignore deleted events
          singleEvents: true,
          orderBy: "startTime",
        },
        // Written like this to allow for use of async calls *inside* the callback function
        async (err, res) => {
          if (err) log_info(err, 1);
          gcal_events = res.data.items;

          /* ======= Create Events on Google Calendar (if they don't already exist) from iCal Events ====== */
          log_info(`Creating events on Google Calendar for ${user.email}`, 1);
          // For loop is written like this to allow for use of async calls *inside* the for loop
          for (const [key, ical_event] of Object.entries(ical_events)) {
            // If not an event (e.g. a timezone or calendar type entry), skip
            if (ical_event.type !== "VEVENT") continue;

            // Create valid google calendar event 'ID' for later use
            // This doesn't use the event's ID property because MySchoolApp changes the ID property sometimes
            unique_descriptor = `AUTOGENERATED by Westtown AutoCal\n ID: ${ical_event.start}\n ${ical_event.summary}\n ${ical_event.end}\n -IR`;

            log_info(`Event: ${ical_event.summary}`, 2, (extra = ical_event));

            // Skip this loop if the event already exists in google calendar
            if (gcal_events.filter((e) => e.description === unique_descriptor).length > 0) {
              log_info("Event already exists in Google Calendar; skipping", 3);
              // Remove this event from the list of gcal_events
              gcal_events = gcal_events.filter((obj) => {
                return obj.description !== unique_descriptor;
              });
            } else {
              log_info("Event doesn't exist in Google Calendar; creating...", 3);
              // Pause each iteration to avoid rate limiting
              await snooze(500);

              calendar.events.insert(
                {
                  calendarId: user.email,
                  resource: {
                    start: {
                      dateTime: ical_event.start,
                      timeZone: ical_event.timeZone,
                    },
                    end: {
                      dateTime: ical_event.end,
                      timeZone: ical_event.timeZone,
                    },
                    summary: ical_event.summary,
                    // Use description as unique identifier for google calendar event
                    description: unique_descriptor,
                    status: "confirmed",
                  },
                },
                (err, res) => {
                  if (err) log_info(err, 3);
                  log_info("Event created", 3);
                }
              );
            }
            // Update progress bar
            newline(3);
            progress_bar.increment();
          }
          /* =========================== Remove Leftover Google Calendar Events =========================== */
          log_info("Removing leftover events from Google Calendar", 1);
          // Remove google calendar events ~made by this script~ that are no longer in the user's ical feed
          progress_bar.start(Object.keys(gcal_events).length, 0);
          for (const [key, gcal_event] of Object.entries(gcal_events)) {
            // Only delete events that are auto-generated by this script
            if (gcal_event?.description?.includes("AUTOGENERATED by Westtown AutoCal")) {
              log_info(`Event: ${gcal_event.summary}`, 2, (extra = gcal_event));
              log_info("Event was auto-generated by this script; removing...", 3);
              // Pause each iteration to avoid rate limiting
              await snooze(500);
              calendar.events.delete({
                calendarId: user.email,
                eventId: gcal_event.id,
              });
            } else {
              log_info(`Event info was redacted for privacy`, 2);
              log_info("Event not generated by this script; skipping", 3);
            }
            // Update progress bar
            newline(3);
            progress_bar.increment();
          }
          // Must be here because this function "finishes" quickly
          log_info(`Finished updating user: ${user.email}'s calendar`, 0);
          return true;
        }
      );
    });
}

async function update_all_users() {
  // For all users in DB, update them using update_user function
  User.find({ ical_feed_url: { $ne: null } }, async (err, users) => {
    for (var i = 0; i < users.length; i++) {
      user = users[i];
      await update_user({ email: user.email, ical_feed_url: user.ical_feed_url });
      console.log("here!");
    }
  });
}

// Create task to check all BGs and schedule it for every 5 minutes (and immediately)
const update_all_users_task = new AsyncTask("update all users' calendars", update_all_users, (err) => {});

function start_update_loop() {
  scheduler.addSimpleIntervalJob(
    new SimpleIntervalJob(
      // Every 2 hours, check all users' feeds and update their calendars
      { minutes: 2 * 60, runImmediately: true },
      update_all_users_task
    )
  );
}
// Allow other files to access the update_user function
// So when a user sets up the service, it runs once for them
module.exports = { start_update_loop, update_user };
